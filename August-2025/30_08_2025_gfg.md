# The Celebrity Problem

**Date:** August 30, 2025  
**Problem URL:** [https://www.geeksforgeeks.org/problems/the-celebrity-problem/1](https://www.geeksforgeeks.org/problems/the-celebrity-problem/1)

## Problem Description

<p><span style="font-size: 14pt;">A celebrity is a person who is known to all but&nbsp;<strong>does not know</strong>&nbsp;anyone at a party. A party is being organized by some people. A square matrix&nbsp;<strong>mat[][]&nbsp;</strong>of size n*n is used to represent people at the party such that if an element of row<strong> i </strong>and column<strong> j </strong>is<strong> set to 1</strong> it means <strong>ith person knows jth person</strong>.&nbsp;You need to return the <strong>index </strong>of the<strong> celebrity</strong> in the party, if the celebrity does not exist, return&nbsp;<strong>-1</strong>.</span></p>
<p><span style="font-size: 14pt;"><strong>Note:</strong>&nbsp;Follow <strong>0-based </strong>indexing.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1, 1, 0],<br />                [0, 1, 0],<br />                [0, 1, 1]]
<strong>Output:</strong> 1
<strong>Explanation: </strong>0th and 2nd person both know 1st person and 1st person does not know anyone. Therefore, 1 is the celebrity person.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1, 1], <br />                [1, 1]]
<strong>Output:</strong> -1
<strong>Explanation: </strong>Since both the people at the party know each other. Hence none of them is a celebrity person.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>mat[][] = [[1]]
<strong>Output:</strong> 0</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br />1 &le; mat.size() &le; 1000<br />0 &le; mat[i][j] &le; 1<br />mat[i][i] = 1</span></p>

## Solution Approaches

### C++ Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```cpp
class Solution {
  public:
    int celebrity(vector<vector<int>>& mat) {
        int n = mat.size();
        int candidate = 0;
        for (int i = 1; i < n; i++) {
            if (mat[candidate][i] == 1) {
                candidate = i;
            }
        }
        
        for (int i = 0; i < n; i++) {
            if (i != candidate) {
                if (mat[candidate][i] == 1 || mat[i][candidate] == 0) {
                    return -1;
                }
            }
        }
        
        return candidate;
    }
};
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Python Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```python
def findCelebrity(mat: list[list[int]]) -> int:
    """
    Finds the celebrity in a party represented by a square matrix.

    Args:
        mat: A square matrix representing people at the party.
             mat[i][j] = 1 if person i knows person j, 0 otherwise.

    Returns:
        The index of the celebrity (0-based), or -1 if no celebrity exists.
    """
    n = len(mat)
    candidate = 0
    for i in range(1, n):
        if mat[candidate][i] == 1:
            candidate = i

    for i in range(n):
        if i != candidate and (mat[candidate][i] == 1 or mat[i][candidate] == 0):
            return -1

    if mat[candidate][candidate] == 0:
        return -1

    for i in range(n):
        if i != candidate and mat[i][candidate] == 0:
            return -1
    return candidate
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Java Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```java
class Solution {
    public int celebrity(int mat[][]) {
        int n = mat.length;
        int candidate = 0;
        for (int i = 1; i < n; i++) {
            if (mat[candidate][i] == 1) {
                candidate = i;
            }
        }

        for (int i = 0; i < n; i++) {
            if (i != candidate && (mat[candidate][i] == 1 || mat[i][candidate] == 0)) {
                return -1;
            }
        }

        return candidate;
    }
}
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### C Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```c
int celebrity(int **mat, int n) {
    int i, j;
    int candidate = 0;

    // Find a potential celebrity
    for (i = 1; i < n; i++) {
        if (mat[candidate][i] == 1) {
            candidate = i;
        }
    }

    // Verify the candidate
    for (i = 0; i < n; i++) {
        if (i != candidate) {
            if (mat[candidate][i] == 1 || mat[i][candidate] == 0) {
                return -1;
            }
        }
    }

    return candidate;
}
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

## Key Takeaways

- [Add key learning points from this problem]
- [Add similar problems to practice]

## Related Problems

- [Add links to similar problems]

---
*Generated by GeeksforGeeks Solution Automation*
