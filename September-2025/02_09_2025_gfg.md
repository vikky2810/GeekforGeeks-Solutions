# Swap Kth nodes from ends

**Date:** September 02, 2025  
**Problem URL:** [https://www.geeksforgeeks.org/problems/swap-kth-node-from-beginning-and-kth-node-from-end-in-a-singly-linked-list/1](https://www.geeksforgeeks.org/problems/swap-kth-node-from-beginning-and-kth-node-from-end-in-a-singly-linked-list/1)

## Problem Description

<p><span style="font-size: 14pt;">Given the <strong>head</strong> of a singly linked list and an integer <strong>k</strong>. <strong>Swap</strong> the k<sup>th</sup> node (1-based index) from the <strong>beginning</strong> and the k<sup>th</sup> node from the <strong>end</strong> of the linked list. Return the head of the final formed list and if it's <strong>not possible</strong> to swap the nodes return the <strong>original</strong> list.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>k = 1,<br />  <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701070/Web/Other/blobid0_1755953423.webp" width="542" height="72" /><br /><strong>Output: </strong>5 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 1<strong>
Explanation: </strong>Here k = 1, hence after swapping the 1st node from the beginning and end the new list will be 5 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 1.<br />  <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701070/Web/Other/blobid1_1755953433.webp" width="541" height="71" /><br /></span></pre>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">k = 2,<br /></span><strong style="font-size: 14pt;">  <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701070/Web/Other/blobid2_1755953453.webp" width="564" height="65" /><br /></strong><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 14pt;">5 -&gt; 9 -&gt; 8 -&gt; 5 -&gt; 10 -&gt; 3</span><strong style="font-size: 14pt;">
Explanation: </strong><span style="font-size: 18.6667px;">Here k = 2, hence after swapping the 2nd node from the beginning and end the new list will be 5 -&gt; 9 -&gt; 8 -&gt; 5 -&gt; 10 -&gt; 3.</span><span style="font-size: 14pt;"><br />  <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/701070/Web/Other/blobid3_1755953462.webp" width="564" height="65" /><br /></span></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong></span><br /><span style="font-size: 14pt;"><span style="font-size: 14pt;">1 &le; list size &le; 10</span><sup>4<br /></sup></span><span style="font-size: 14pt;"><span style="font-size: 18.6667px;">1 &le; node-&gt;data &le; 10<sup>6<br /></sup></span></span><span style="font-size: 14pt;">1 &le; k &le; 10<sup>4</sup></span></p>

## Solution Approaches

### C++ Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```cpp
/*
class Node {
  public:
    int data;
    Node *next;

    Node(int x) {
        data = x;
        next = NULL;
    }
};
*/

class Solution {
  public:
    Node* swapKth(Node* head, int k) {
        // code here
        if (!head) return head;

        Node* current = head;
        int n = 0;
        while (current != NULL) {
            n++;
            current = current->next;
        }

        if (k > n) return head;
        if (2 * k - 1 == n) return head;

        Node* x = head;
        Node* x_prev = NULL;
        for (int i = 1; i < k; i++) {
            x_prev = x;
            x = x->next;
        }

        Node* y = head;
        Node* y_prev = NULL;
        for (int i = 1; i < n - k + 1; i++) {
            y_prev = y;
            y = y->next;
        }

        if (x_prev)
            x_prev->next = y;
        if (y_prev)
            y_prev->next = x;

        Node* temp = x->next;
        x->next = y->next;
        y->next = temp;

        if (k == 1)
            head = y;
        else if (k == n)
            head = x;

        return head;
    }
};
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Python Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```python
class Solution:
    def swapKthNode(self, head, k):
        """
        Swaps the kth node from the beginning and the kth node from the end of a singly linked list.

        Args:
            head: The head of the singly linked list.
            k: The index of the node to swap (1-based index).

        Returns:
            The head of the modified linked list after swapping, or the original list if the swap is not possible.
        """
        if not head or k <= 0:
            return head

        # Find the length of the linked list
        length = 0
        curr = head
        while curr:
            length += 1
            curr = curr.next

        if k > length:
            return head

        if 2 * k - 1 == length:
            return head
        
        # Find kth node from beginning and its predecessor
        prev_k_start = None
        curr_k_start = head
        for _ in range(k - 1):
            prev_k_start = curr_k_start
            curr_k_start = curr_k_start.next

        # Find kth node from end and its predecessor
        prev_k_end = None
        curr_k_end = head
        for _ in range(length - k):
            prev_k_end = curr_k_end
            curr_k_end = curr_k_end.next

        # Swap the nodes
        if prev_k_start:
            prev_k_start.next = curr_k_end
        if prev_k_end:
            prev_k_end.next = curr_k_start

        temp = curr_k_start.next
        curr_k_start.next = curr_k_end.next
        curr_k_end.next = temp

        if k == 1:
            head = curr_k_end
        elif k == length:
            head = curr_k_start

        return head
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Java Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```java
/*
class Node {
    int data;
    Node next;

    Node(int x) {
        data = x;
        next = null;
    }
}
*/
class Solution {
    public Node swapKth(Node head, int k) {
        if (head == null || head.next == null) {
            return head;
        }

        int n = 0;
        Node current = head;
        while (current != null) {
            n++;
            current = current.next;
        }

        if (k > n) {
            return head;
        }

        if (2 * k - 1 == n) {
            return head;
        }

        Node x = head;
        Node x_prev = null;
        for (int i = 1; i < k; i++) {
            x_prev = x;
            x = x.next;
        }

        Node y = head;
        Node y_prev = null;
        for (int i = 1; i < n - k + 1; i++) {
            y_prev = y;
            y = y.next;
        }

        if (x_prev != null) {
            x_prev.next = y;
        }

        if (y_prev != null) {
            y_prev.next = x;
        }

        Node temp = x.next;
        x.next = y.next;
        y.next = temp;

        if (k == 1) {
            head = y;
        }

        if (k == n) {
            head = x;
        }
        
        return head;
    }
}
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

## Key Takeaways

- [Add key learning points from this problem]
- [Add similar problems to practice]

## Related Problems

- [Add links to similar problems]

---
*Generated by GeeksforGeeks Solution Automation*
