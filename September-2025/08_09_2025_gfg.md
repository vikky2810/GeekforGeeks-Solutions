# Merge Sort for Linked List

**Date:** September 08, 2025  
**Problem URL:** [https://www.geeksforgeeks.org/problems/sort-a-linked-list/1](https://www.geeksforgeeks.org/problems/sort-a-linked-list/1)

## Problem Description

<p><span style="font-size: 18px;">You are given the <strong>head </strong>of a linked list. You have to sort the given linked list using<strong> Merge Sort</strong>.</span></p>
<p><span style="font-size: 18px;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 18px;"><strong>Input:</strong><br />    <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908586/Web/Other/blobid0_1756114630.jpg" width="556" height="66" /><br /><strong>Output: </strong>10 -&gt; 20 -&gt; 30 -&gt; 40 -&gt; 50 -&gt; 60<br /><strong>Explanation: </strong>After sorting the given linked list, the resultant list will be:<br />    <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908586/Web/Other/blobid1_1756114636.jpg" width="557" height="66" /></span></pre>
<pre><span style="font-size: 18px;"><strong>Input:</strong><br />    <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908586/Web/Other/blobid2_1756114643.jpg" width="401" height="63" /><br /><strong>Output: </strong>2<strong> </strong>-&gt; 5 -&gt; 8 -&gt; 9<br /></span><span style="font-size: 18px;"><strong>Explanation: </strong>After sorting the given linked list, the resultant list will be:<br />    <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908586/Web/Other/blobid3_1756114660.jpg" width="407" height="64" /></span></pre>
<p><span style="font-size: 18px;"><strong>Constraints:</strong><br />1 &le; number of nodes &le; 10<sup>5<br /></sup>0 &le; node-&gt;data &le; 10<sup>6</sup></span></p>

## Solution Approaches

### C++ Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```cpp
/*
class Node {
public:
    int data;
    Node* next;

    Node(int x){
        data = x;
        next = NULL;
    }
};
*/
class Solution {
  public:
    Node* mergeSort(Node* head) {
        // code here
        if (!head || !head->next) {
            return head;
        }

        Node* slow = head;
        Node* fast = head->next;

        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        Node* mid = slow->next;
        slow->next = nullptr;

        Node* left = mergeSort(head);
        Node* right = mergeSort(mid);

        return merge(left, right);
    }

    Node* merge(Node* left, Node* right) {
        Node* dummy = new Node(-1);
        Node* tail = dummy;

        while (left && right) {
            if (left->data <= right->data) {
                tail->next = left;
                left = left->next;
            } else {
                tail->next = right;
                right = right->next;
            }
            tail = tail->next;
        }

        if (left) {
            tail->next = left;
        } else {
            tail->next = right;
        }

        return dummy->next;
    }
};
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Python Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```python
class Solution:
    def mergeSort(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head or not head.next:
            return head

        # Find the middle of the linked list using the slow and fast pointer approach.
        slow = head
        fast = head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # Split the linked list into two halves.
        mid = slow.next
        slow.next = None

        # Recursively sort the two halves.
        left = self.mergeSort(head)
        right = self.mergeSort(mid)

        # Merge the two sorted halves.
        return self.merge(left, right)

    def merge(self, left, right):
        """
        Merges two sorted linked lists into a single sorted linked list.
        :type left: ListNode
        :type right: ListNode
        :rtype: ListNode
        """
        dummy = ListNode(0)
        tail = dummy

        while left and right:
            if left.data < right.data:
                tail.next = left
                left = left.next
            else:
                tail.next = right
                right = right.next
            tail = tail.next

        if left:
            tail.next = left
        if right:
            tail.next = right

        return dummy.next
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Java Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```java
/*
class Node {
    int data;
    Node next;

    Node(int key) {
        data = key;
        next = null;
    }
}
*/

class Solution {
    public Node mergeSort(Node head) {
        // code here
        if (head == null || head.next == null) {
            return head;
        }

        Node middle = getMiddle(head);
        Node nextOfMiddle = middle.next;

        middle.next = null;

        Node left = mergeSort(head);
        Node right = mergeSort(nextOfMiddle);

        Node sortedList = merge(left, right);
        return sortedList;
    }

    private Node getMiddle(Node head) {
        if (head == null) {
            return head;
        }

        Node slow = head, fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    private Node merge(Node a, Node b) {
        Node result = null;

        if (a == null) {
            return b;
        }

        if (b == null) {
            return a;
        }

        if (a.data <= b.data) {
            result = a;
            result.next = merge(a.next, b);
        } else {
            result = b;
            result.next = merge(a, b.next);
        }

        return result;
    }
}
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

## Key Takeaways

- [Add key learning points from this problem]
- [Add similar problems to practice]

## Related Problems

- [Add links to similar problems]

---
*Generated by GeeksforGeeks Solution Automation*
