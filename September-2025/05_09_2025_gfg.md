# Sort a linked list of 0s, 1s and 2s

**Date:** September 05, 2025  
**Problem URL:** [https://www.geeksforgeeks.org/problems/given-a-linked-list-of-0s-1s-and-2s-sort-it/1](https://www.geeksforgeeks.org/problems/given-a-linked-list-of-0s-1s-and-2s-sort-it/1)

## Problem Description

<p><span style="font-size: 14pt;">Given the <strong>head</strong> of a linked list where nodes can contain values </span><strong style="font-size: 14pt;">0s</strong><span style="font-size: 14pt;">,&nbsp;</span><strong style="font-size: 14pt;">1s,</strong><span style="font-size: 14pt;">&nbsp;and&nbsp;</span><strong style="font-size: 14pt;">2s&nbsp;</strong><span style="font-size: 14pt;">only. Your</span><span style="font-size: 18.6667px;">&nbsp;task is to&nbsp;<strong>rearrange</strong>&nbsp;the list so that all&nbsp;<strong>0s</strong>&nbsp;appear at the beginning, followed by all&nbsp;<strong>1s</strong>, and all&nbsp;<strong>2s</strong>&nbsp;are placed at the end.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Input: </strong><span style="font-size: 14pt;">head =</span><strong style="font-size: 14pt;"> </strong><span style="font-size: 14pt;">1 &rarr; 2 &rarr; 2 &rarr; 1 &rarr; 2 &rarr; 0 &rarr; 2 &rarr; 2<br />   <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908245/Web/Other/blobid0_1756113569.jpg" width="691" height="67" /><br /></span></span><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Output: </strong><span style="font-size: 18.6667px;">0 &rarr; 1 &rarr; 1 &rarr; 2 &rarr; 2 &rarr; 2 &rarr; 2 &rarr; 2<br /></span></span><span style="font-size: 14pt;"><strong style="font-size: 14pt;">Explanation: </strong><span style="font-size: 14pt;">All the 0s are segregated to the left end of the linked list, 2s to the right end of the list, and 1s in between. The final list will be:<br />   <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908245/Web/Other/blobid1_1756113598.jpg" width="680" height="66" /></span></span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>head = 2 &rarr; 2 &rarr; 0 &rarr; 1<br />   <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908245/Web/Other/blobid2_1756113607.jpg" width="457" height="75" /><br /><strong>Output: </strong>0 &rarr; 1 &rarr; 2 &rarr; 2<br /></span><span style="font-size: 14pt;"><strong>Explanation: </strong>After arranging all the 0s, 1s and 2s in the given format, the output will be:<br />   <img src="https://media.geeksforgeeks.org/img-practice/prod/addEditProblem/908245/Web/Other/blobid3_1756113615.jpg" width="457" height="75" /></span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:</strong><br /><span style="font-size: 14pt;">1 &le; no. of nodes &le; 10<sup>6</sup></span><br style="font-size: medium;" /><span style="font-size: 14pt;">0 &le; node-&gt;data &le; 2</span></span></p>

## Solution Approaches

### C++ Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```cpp
/* Node is defined as
  class Node {
  public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = nullptr;
    }
};
*/
class Solution {
  public:
    Node* segregate(Node* head) {
        // code here
        Node* zeroHead = new Node(-1);
        Node* oneHead = new Node(-1);
        Node* twoHead = new Node(-1);
        
        Node* zeroTail = zeroHead;
        Node* oneTail = oneHead;
        Node* twoTail = twoHead;
        
        Node* curr = head;
        
        while(curr != nullptr){
            if(curr->data == 0){
                zeroTail->next = curr;
                zeroTail = curr;
            } else if(curr->data == 1){
                oneTail->next = curr;
                oneTail = curr;
            } else {
                twoTail->next = curr;
                twoTail = curr;
            }
            curr = curr->next;
        }
        
        zeroTail->next = (oneHead->next != nullptr) ? oneHead->next : twoHead->next;
        oneTail->next = twoHead->next;
        twoTail->next = nullptr;
        
        Node* newHead = zeroHead->next;
        
        delete zeroHead;
        delete oneHead;
        delete twoHead;
        
        return newHead;
    }
};
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Python Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```python
class Node:  # Assuming a Node class exists (or will be created)
    def __init__(self, data):
        self.data = data
        self.next = None

    def sortLinkedList(self, head: Node) -> Node:
        """
        Rearranges a linked list with nodes containing 0s, 1s, and 2s so that all 0s appear at the beginning,
        followed by all 1s, and all 2s are placed at the end.

        Args:
            head: The head of the linked list.

        Returns:
            The head of the rearranged linked list.
        """
        count0 = 0
        count1 = 0
        count2 = 0

        curr = head
        while curr:
            if curr.data == 0:
                count0 += 1
            elif curr.data == 1:
                count1 += 1
            else:
                count2 += 1
            curr = curr.next

        curr = head
        while count0 > 0:
            curr.data = 0
            curr = curr.next
            count0 -= 1

        while count1 > 0:
            curr.data = 1
            curr = curr.next
            count1 -= 1

        while count2 > 0:
            curr.data = 2
            curr = curr.next
            count2 -= 1

        return head
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Java Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```java
/*
class Node {
    int data;
    Node next;

    Node(int d)
    {
        data = d;
        next = null;
    }
}*/

class Solution {
    public Node segregate(Node head) {
        // code here
        Node zeroHead = new Node(-1);
        Node oneHead = new Node(-1);
        Node twoHead = new Node(-1);

        Node zeroTail = zeroHead;
        Node oneTail = oneHead;
        Node twoTail = twoHead;

        Node curr = head;

        while (curr != null) {
            if (curr.data == 0) {
                zeroTail.next = curr;
                zeroTail = curr;
            } else if (curr.data == 1) {
                oneTail.next = curr;
                oneTail = curr;
            } else {
                twoTail.next = curr;
                twoTail = curr;
            }
            curr = curr.next;
        }

        zeroTail.next = (oneHead.next != null) ? oneHead.next : twoHead.next;
        oneTail.next = twoHead.next;
        twoTail.next = null;

        return (zeroHead.next != null) ? zeroHead.next : ((oneHead.next != null) ? oneHead.next : twoHead.next);
    }
}
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

## Key Takeaways

- [Add key learning points from this problem]
- [Add similar problems to practice]

## Related Problems

- [Add links to similar problems]

---
*Generated by GeeksforGeeks Solution Automation*
