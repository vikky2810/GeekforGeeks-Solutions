# Sum of Mode

**Date:** September 01, 2025  
**Problem URL:** [https://www.geeksforgeeks.org/problems/sum-of-mode/1](https://www.geeksforgeeks.org/problems/sum-of-mode/1)

## Problem Description

<p><span style="font-size: 14pt;">Given an array <strong>arr[]</strong> of positive integers and an integer <strong>k</strong>. You have to find the sum of the <strong>modes</strong> of all the subarrays of size <strong>k</strong>.</span><br /><span style="font-size: 14pt;"><strong>Note:</strong>&nbsp;</span><span style="font-size: 18.6667px;">The mode of a subarray is the element that occurs with the highest frequency. If multiple elements have the same highest frequency, the smallest such element is considered the mode.</span></p>
<p><span style="font-size: 14pt;"><strong>Examples:</strong></span></p>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [1, 2, 3, 2, 5, 2, 4, 4], k = 3<strong><br />Output:</strong> 13<strong><br />Explanation:</strong> The mode of each k size subarray is [1, 2, 2, 2, 2, 4] and sum of all modes is 13.</span></pre>
<pre><span style="font-size: 14pt;"><strong>Input: </strong>arr[] = [1, 2, 1, 3, 5], k = 2<strong><br />Output:</strong> 6<strong><br />Explanation:&nbsp;</strong>The mode of each k size subarray is [1, 1, 1, 3] and sum of all modes is 6.</span></pre>
<p><span style="font-size: 14pt;"><strong>Constraints:<br /></strong>1 &le; k &le; arr.size() &le;10<sup>5</sup><br />1 &le; arr[i] &le; 10<sup>5</sup></span></p>

## Solution Approaches

### C++ Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```cpp
class Solution {
  public:
    int sumOfModes(vector<int>& arr, int k) {
        int n = arr.size();
        int sum = 0;
        for (int i = 0; i <= n - k; ++i) {
            vector<int> subarray;
            for (int j = 0; j < k; ++j) {
                subarray.push_back(arr[i + j]);
            }

            unordered_map<int, int> counts;
            int max_freq = 0;
            int mode = -1;

            for (int num : subarray) {
                counts[num]++;
                if (counts[num] > max_freq) {
                    max_freq = counts[num];
                    mode = num;
                } else if (counts[num] == max_freq && num < mode) {
                    mode = num;
                }
            }
            sum += mode;
        }
        return sum;
    }
};
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Python Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```python
def sum_of_modes(arr, k):
    """
    Calculates the sum of the modes of all subarrays of size k in the given array.

    Args:
        arr: A list of positive integers.
        k: An integer representing the size of the subarrays.

    Returns:
        The sum of the modes of all subarrays of size k.
    """
    n = len(arr)
    modes_sum = 0
    for i in range(n - k + 1):
        subarray = arr[i:i + k]
        counts = {}
        for num in subarray:
            counts[num] = counts.get(num, 0) + 1
        
        max_freq = 0
        mode = float('inf')
        for num, freq in counts.items():
            if freq > max_freq:
                max_freq = freq
                mode = num
            elif freq == max_freq and num < mode:
                mode = num
        modes_sum += mode
    return modes_sum
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

### Java Solution

**Time Complexity:** O(1) - Please update based on your algorithm
**Space Complexity:** O(1) - Please update based on your algorithm

```java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int sumOfModes(int[] arr, int k) {
        int sum = 0;
        for (int i = 0; i <= arr.length - k; i++) {
            int mode = findMode(arr, i, k);
            sum += mode;
        }
        return sum;
    }

    private int findMode(int[] arr, int start, int k) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        int mode = -1;
        int maxFrequency = 0;

        for (int i = start; i < start + k; i++) {
            int num = arr[i];
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
            int frequency = frequencyMap.get(num);

            if (frequency > maxFrequency) {
                maxFrequency = frequency;
                mode = num;
            } else if (frequency == maxFrequency) {
                if (num < mode || mode == -1) {
                    mode = num;
                }
            }
        }

        return mode;
    }
}
```

**Explanation:**
- Algorithm: [Describe the algorithm used]
- Key Insights: [Explain the key insights]
- Edge Cases: [List important edge cases]

## Key Takeaways

- [Add key learning points from this problem]
- [Add similar problems to practice]

## Related Problems

- [Add links to similar problems]

---
*Generated by GeeksforGeeks Solution Automation*
